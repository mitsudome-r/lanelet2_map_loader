#include "ros/ros.h"
#include <tf/tf.h>
#include <tf/transform_listener.h>
#include <tf/transform_broadcaster.h>
#include <sensor_msgs/CameraInfo.h>
#include <geometry_msgs/TwistStamped.h>
#include <geometry_msgs/Pose.h>
#include <geometry_msgs/PoseStamped.h>

#include <visualization_msgs/Marker.h>
#include <visualization_msgs/MarkerArray.h>


#include "std_msgs/String.h"
#include <lanelet2_core/primitives/Lanelet.h>
#include <lanelet2_io/Io.h>
#include <lanelet2_io/io_handlers/Factory.h>
#include <lanelet2_io/io_handlers/Parser.h>
#include <lanelet2_io/io_handlers/OsmHandler.h>
#include <lanelet2_io/io_handlers/OsmFile.h>

#include <lanelet2_projection/UTM.h>
#include <lanelet2_core/LaneletMap.h>
#include <lanelet2_core/primitives/BasicRegulatoryElements.h>
#include <lanelet2_core/primitives/LineString.h>
#include <lanelet2_core/primitives/LineStringOrPolygon.h>

#include <lanelet2_traffic_rules/TrafficRules.h>
#include <lanelet2_traffic_rules/TrafficRulesFactory.h>



#include <lanelet2_routing/Route.h>
#include <lanelet2_routing/RoutingCost.h>
#include <lanelet2_routing/RoutingGraph.h>
#include <lanelet2_routing/RoutingGraphContainer.h>

#include <lanelet2_core/geometry/BoundingBox.h>
#include <lanelet2_core/geometry/Lanelet.h>
#include <lanelet2_core/geometry/Point.h>

#include <lanelet2_core/primitives/Lanelet.h>
#include <Eigen/Eigen>

#include <autoware_msgs/Signals.h>

#include <cstdio>

#include <sstream>
#include "rosUTM.h"
#include "libLaneletMap.h"
#include <lanelet_msgs/PointArray.h>
#include <lanelet_msgs/MapXML.h>
#include <pugixml.hpp>





#include <unistd.h>
#include <ios>
#include <iostream>
#include <fstream>
#include <string>

//std::string example_map_path = "/home/simon/work/catkin_ws/src/lanelet2/lanelet2_maps/res/mapping_example.osm";
std::string example_map_path = "/home/simon/work/peoria_data/map/Lanelet2/Peoria_0301_2019_fixed.osm";




//-------------------------------------------------------------------------
//
//
//
//-------------------------------------------------------------------------




//-------------------------------------------------------------------------
//
//
//
//-------------------------------------------------------------------------

void make_light_marker(lanelet::Point3d p, visualization_msgs::Marker& marker, std::string frame_id, std::string ns, int tl_count, int point_count){
  
  uint32_t box_shape = visualization_msgs::Marker::CUBE; 
  
  marker.header.frame_id = frame_id;
  marker.header.stamp = ros::Time::now();
  marker.ns = ns;
  marker.id = tl_count*10+point_count;
  marker.type = box_shape;
  marker.pose.position.x = p.x();
  marker.pose.position.y = p.y();
  marker.pose.position.z = p.z();
  
  float s = 0.5;

  marker.scale.x = s;
  marker.scale.y = s;
  marker.scale.z = s;
  
  marker.color.r = 0.0f;
  marker.color.g = 0.0f;
  marker.color.b = 0.0f;
  marker.color.a = 1.0f;
  
  if (point_count == 0) marker.color.r = 1.0f;
  else if (point_count == 1) marker.color.g = 1.0f;
  if (point_count == 2) marker.color.b = 1.0f;
  
  marker.lifetime = ros::Duration();
}




//-------------------------------------------------------------------------
//
//
//
//-------------------------------------------------------------------------


void delete_linestring_marker(visualization_msgs::Marker& points, visualization_msgs::Marker& line_strip , std::string ns, int lane_id){
  
  points.header.frame_id = line_strip.header.frame_id = "map";
  points.header.stamp = line_strip.header.stamp = ros::Time::now();

  points.ns = line_strip.ns;
  points.id = lane_id*10+0;
  line_strip.id = lane_id*10+1;
  points.action = line_strip.action = visualization_msgs::Marker::ADD;

  points.type = visualization_msgs::Marker::POINTS;
  line_strip.type = visualization_msgs::Marker::LINE_STRIP;
  geometry_msgs::Point p;
  p.x = 0;
  p.y = 0;
  p.z = 0; //(*i).z();

  for (int i = 0; i < 100; i++) {points.points.push_back(p);
  line_strip.points.push_back(p);
  }
  
}

void build_location_marker(int id, lanelet::BasicPoint2d location, visualization_msgs::Marker& m,
			   std::string frame_id, std::string ns, float r, float g, float b, float s= 0.15)
{
  
  
  m.header.frame_id = frame_id;
  m.header.stamp = ros::Time::now();
  m.ns = ns;
  m.action = visualization_msgs::Marker::ADD;

  m.type = visualization_msgs::Marker::POINTS;
  
  m.pose.orientation.w = 1.0;
  m.id = id;
  m.scale.x = s;
  m.scale.y = s;

  m.color.r = r;
  m.color.g = g;
  m.color.b = b;
  m.color.a = 1.0f;
  geometry_msgs::Point p;
  p.x = location.x();
  p.y = location.y();
  p.z = 118.0; //(*i).z();
  m.points.push_back(p);
}



void visualize_lanelet_linestring(int lane_id, lanelet::ConstLineString3d ls, visualization_msgs::Marker& points,
				  visualization_msgs::Marker& line_strip,
				  std::string frame_id, std::string ns, float lr, float lg, float lb, float lss= 0.1)
{

  
  points.header.frame_id = line_strip.header.frame_id = frame_id;
  points.header.stamp = line_strip.header.stamp = ros::Time::now();
  points.ns = line_strip.ns = ns;
  points.action = line_strip.action = visualization_msgs::Marker::ADD;
  
  points.pose.orientation.w = line_strip.pose.orientation.w = 1.0;
  points.id = lane_id*10+0;
  line_strip.id = lane_id*10+1;

  points.type = visualization_msgs::Marker::POINTS;
  line_strip.type = visualization_msgs::Marker::LINE_STRIP;
	
  points.scale.x = 0.2;
  points.scale.y = 0.2;
  line_strip.scale.x = lss; 


  points.color.g = 1.0f;
  points.color.a = 1.0f;
  line_strip.color.r = lr;
  line_strip.color.g = lg;
  line_strip.color.b = lb;
  line_strip.color.a = 1.0f;

  // fill out lane line
  for (auto i = ls.begin(); i != ls.end(); i++){
    geometry_msgs::Point p;
    p.x = (*i).x();
    p.y = (*i).y();
    p.z = 118.0; //(*i).z();
    points.points.push_back(p);
    line_strip.points.push_back(p);
  }
}


void visualize_lanelet(lanelet::ConstLanelet & lanelet, ros::Publisher &pub,
		       float *lline, float *rline, std::string ns, int id){
  visualization_msgs::Marker left_line_strip, left_points, right_line_strip, right_points;

  lanelet::ConstLineString3d left_ls = lanelet.leftBound();
  lanelet::ConstLineString3d right_ls = lanelet.rightBound();
	  

  visualize_lanelet_linestring(id*10+0, left_ls, left_points, left_line_strip, "map", "left_lane_bound", lline[0], lline[1], lline[2], lline[3]);
  visualize_lanelet_linestring(id*10+1,right_ls, right_points, right_line_strip, "map", "right_lane_bound", rline[0], rline[1], rline[2], rline[3]);
  
  pub.publish(left_points);
  pub.publish(left_line_strip);
  pub.publish(right_points);
  pub.publish(right_line_strip);
 }



void visualize_lanelet_map(ros::Publisher& pub, lanelet::LaneletMap& lanelet_map){
  

  visualization_msgs::MarkerArray left_ls_array;
  visualization_msgs::MarkerArray right_ls_array;
  visualization_msgs::MarkerArray center_ls_array;
  left_ls_array.markers.resize(lanelet_map.laneletLayer.size());
  right_ls_array.markers.resize(lanelet_map.laneletLayer.size());
  center_ls_array.markers.resize(lanelet_map.laneletLayer.size());
  int lanelet_count = 0;
  for (auto i = lanelet_map.laneletLayer.begin(); i != lanelet_map.laneletLayer.end(); i++) {
    lanelet::Lanelet ll = *i;
    
    lanelet::ConstLineString3d left_ls = ll.leftBound();
    lanelet::ConstLineString3d right_ls = ll.rightBound();
    lanelet::ConstLineString3d center_ls = ll.centerline();
    visualization_msgs::Marker left_line_strip, left_points, right_line_strip, right_points, center_line_strip, center_points;
    
    visualize_lanelet_linestring(lanelet_count, left_ls, left_points, left_ls_array.markers[lanelet_count], "map", "aleft_lane_bound", 1.0f, 0.0f, 0.0f);
    visualize_lanelet_linestring(lanelet_count,right_ls, right_points, right_ls_array.markers[lanelet_count], "map", "aright_lane_bound",0.0f, 0.0f, 1.0f);
    visualize_lanelet_linestring(lanelet_count,center_ls, center_points, center_ls_array.markers[lanelet_count], "map", "acenter_lane_bound",0.0f, 1.0f, 1.0f);
    // left_ls_array.markers[lanelet_count] = left_ls;
    lanelet_count++;
  }
  //  std::cerr << "laneclet count = " << lanelet_count << "\n";
  //  std::cerr << "marker array size = " << left_ls_array.markers.size() << "\n";


  //  ros::spinOnce();
  pub.publish(left_ls_array);
  pub.publish(right_ls_array);
  pub.publish(center_ls_array);
  
}



lanelet::LaneletMapPtr lanelet_map;
//-------------------------------------------------------------------------
//
//
//
//-------------------------------------------------------------------------

/*
int xmlMapMsgToLaneletMap(lanelet_msgs::MapXML msg, lanelet::LaneletMapPtr map)
{
  int status = 0;
  lanelet::Origin origin({49, 8.4});
  
  // origin not used in projector but projector template requires one
  lanelet::projection::RosUtmProjector ros_projector(origin);
  
  lanelet::ErrorMessages errors;
  
  std::cerr << "Recievd lanelet map xml string message size = " << msg.xml_map.size() << "\n";

  // got map in xml form
  // now reverse the steps used to publish
  // string -> srtingstream -> xml doc -> osm format ->lanelet map

  
  std::stringstream ss;
  ss << msg;
  pugi::xml_document pugi_xml_doc;
  pugi::xml_parse_result result = pugi_xml_doc.load(ss); 
  if (result.status == pugi::status_ok) {
    // failed beacuse no default projector set, now works
    lanelet::osm::File map_osm = lanelet::osm::read(pugi_xml_doc);  // read a map in to an osm file data structure
    lanelet::io_handlers::OsmParser osm_parser(ros_projector);
    
    map = osm_parser.fromOsmFile(map_osm, errors);
    status = 1;
   
  }
  else {
    std::cerr << "WARNING xmlMapToLaneletMap(): could not load xml string stream into xml document\n";
  }
  return status;

}
*/
void xmlMapCallback(lanelet_msgs::MapXML msg)
{
  //int status = xmlMapMsgToLaneletMap(msg, lanelet_map);
  int status = lanelet_utils::Map::fromXMLMsg(msg, lanelet_map);
}
//-------------------------------------------------------------------------
//
//
//
//-------------------------------------------------------------------------

int main (int argc, char **argv)
{

  
  ros::init(argc, argv, "lanelet_map_subscriber");  
  ros::NodeHandle rosnode;
  
  ros::Subscriber xml_map_sub = rosnode.subscribe("/lanelet_map_xml", 10000,  xmlMapCallback);

  // make example which visualises map
  //  ros::Publisher marker_array_pub = rosnode.advertise<visualization_msgs::MarkerArray>("lanelet_left_ls_marker_array", 100);
  
    
  ros::spinOnce();
  ros::Rate loop_rate(10);
  int loop_count = 0;
  
  while(ros::ok()) // && loop_count < 10)
    {
      
      ros::spinOnce();
      loop_count++;
    }
  
  return 0;
}
